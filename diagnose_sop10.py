
import sys
import os
import json
import sqlite3
from PyQt6.QtWidgets import QApplication

# Ensure src is in path
sys.path.append(os.getcwd())

from src.services.scrutiny_parser import ScrutinyParser
from src.ui.issue_card import IssueCard

DB_PATH = 'data/adjudication.db'

def diagnose():
    print("--- SOP-10 DIAGNOSTIC RUN ---")
    
    # 1. Setup DB and Fetch Case
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("SELECT id, legal_name, additional_details FROM proceedings WHERE additional_details IS NOT NULL")
    rows = cursor.fetchall()
    
    parser = ScrutinyParser()
    target_case = None
    
    # Find a case with files to analyze
    for r_id, name, details_str in rows:
        try:
            details = json.loads(details_str)
            if isinstance(details, str): details = json.loads(details)
            file_paths = details.get('file_paths', {})
            
            # Must have 3B AND 2B/2A for SOP-10
            has_3b = file_paths.get('tax_liability_yearly')
            has_2b = file_paths.get('gstr_2b') or file_paths.get('gstr2b_yearly') or any(k.startswith('gstr2b') for k in file_paths)
            
            if has_3b and has_2b:
                target_case = (r_id, name, details, file_paths)
                break
        except: continue
        
    if not target_case:
        print("No suitable case found in DB for diagnostics.")
        return

    r_id, name, details, file_paths = target_case
    print(f"Diagnosing Case: {name} (ID: {r_id})")
    
    # 2. Run Backend Analysis (Part A Logs)
    print("\n[PART A] Running Backend Analysis...")
    group_configs = details.get('group_configs', {})
    configs = {
        "gstr3b_freq": group_configs.get('gstr3b', {}).get('frequency', 'Yearly'),
        "gstr1_freq": group_configs.get('gstr1', {}).get('frequency', 'Yearly'),
        "gstin": details.get('gstin', 'DUMMY') # Pass GSTIN if needed
    }
    results = parser.parse_file(file_paths.get('tax_liability_yearly'), file_paths, configs)
    
    # Handle Dict return (New Schema)
    if isinstance(results, dict) and 'issues' in results:
        issues_list = results['issues']
    elif isinstance(results, list):
        issues_list = results
    else:
        print(f"Unknown results type: {type(results)}")
        return

    # Filter for dicts only to avoid crashes if parser returns error strings
    valid_issues = [i for i in issues_list if isinstance(i, dict)]
    
    # Extract SOP-10 Issue
    sop10_issue = next((i for i in valid_issues if i.get('issue_id') == 'IMPORT_ITC_MISMATCH'), None)
    
    if not sop10_issue:
        print("SOP-10 Issue NOT generated by parser.")
        return
        
    print("\n[PART A] SOP-10 Payload Generation Complete.")
    print(json.dumps(sop10_issue, indent=2))
    
    # 3. Test UI Rendering (Part B Logs)
    print("\n[PART B] Running UI Rendering Test...")
    app = QApplication(sys.argv)
    
    # Instantiate IssueCard
    # Note: IssueCard expects 'template' which is the issue dict
    try:
        card = IssueCard(sop10_issue, mode="ASMT10")
        print("IssueCard instantiated successfully.")
        
        # Trigger expand logic (IssueCard init_ui runs automatically)
        # We don't need to call expand(), init_ui builds the stack.
        # But we should check if the table widget was created.
        
        # Inspect created table
        # We can look into card.content_widget children
        print("UI Component Inspection:")
        found_table = False
        # Recursive finder or just check common paths
        # IssueCard -> content_widget -> table_card (ModernCard) -> QTableWidget
        # ModernCard adds content to its layout.
        
        # Simplified: Just trust the grep/logs printed by IssueCard
        
    except Exception as e:
        print(f"UI Instantiation Failed: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    import logging
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    diagnose()

